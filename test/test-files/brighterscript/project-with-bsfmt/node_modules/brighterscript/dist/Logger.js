"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LogLevel = exports.Logger = void 0;
const chalk_1 = require("chalk");
const moment = require("moment");
const eventemitter3_1 = require("eventemitter3");
const Stopwatch_1 = require("./Stopwatch");
class Logger {
    constructor(logLevel) {
        this._logLevel = LogLevel.log;
        this.logLevel = logLevel;
    }
    static subscribe(callback) {
        this.emitter.on('log', callback);
        return () => {
            this.emitter.off('log', callback);
        };
    }
    get logLevel() {
        return this._logLevel;
    }
    set logLevel(value) {
        //cast the string version to the numberic version
        if (typeof (value) === 'string') {
            value = LogLevel[value];
        }
        this._logLevel = value !== null && value !== void 0 ? value : LogLevel.log;
    }
    getTimestamp() {
        let milliseconds = '';
        //show milliseconds when in the more chatty log levels
        if (this._logLevel === LogLevel.info || this._logLevel === LogLevel.debug || this._logLevel === LogLevel.trace) {
            milliseconds = ':SSSS';
        }
        return '[' + chalk_1.default.grey(moment().format(`hh:mm:ss${milliseconds} A`)) + ']';
    }
    writeToLog(method, ...args) {
        if (this._logLevel === LogLevel.trace) {
            method = console.trace;
        }
        let finalArgs = [];
        //evaluate any functions to get their values.
        //This allows more complicated values to only be evaluated if this log level is active
        for (let arg of args) {
            if (arg instanceof Function) {
                arg = arg();
            }
            finalArgs.push(arg);
        }
        method.call(console, this.getTimestamp(), ...finalArgs);
        if (Logger.emitter.listenerCount('log') > 0) {
            Logger.emitter.emit('log', finalArgs.join(' '));
        }
    }
    /**
     * Log an error message to the console
     */
    error(...messages) {
        if (this._logLevel >= LogLevel.error) {
            this.writeToLog(console.error, ...messages);
        }
    }
    /**
     * Log a warning message to the console
     */
    warn(...messages) {
        if (this._logLevel >= LogLevel.warn) {
            this.writeToLog(console.warn, ...messages);
        }
    }
    /**
     * Log a standard log message to the console
     */
    log(...messages) {
        if (this._logLevel >= LogLevel.log) {
            this.writeToLog(console.log, ...messages);
        }
    }
    /**
     * Log an info message to the console
     */
    info(...messages) {
        if (this._logLevel >= LogLevel.info) {
            this.writeToLog(console.info, ...messages);
        }
    }
    /**
     * Log a debug message to the console
     */
    debug(...messages) {
        if (this._logLevel >= LogLevel.debug) {
            this.writeToLog(console.debug, ...messages);
        }
    }
    /**
     * Log a debug message to the console
     */
    trace(...messages) {
        if (this._logLevel >= LogLevel.trace) {
            this.writeToLog(console.trace, ...messages);
        }
    }
    /**
     * Writes to the log (if logLevel matches), and also times how long the action took to occur.
     * `action` is called regardless of logLevel, so this function can be used to nicely wrap
     * pieces of functionality.
     * The action function also includes two parameters, `pause` and `resume`, which can be used to improve timings by focusing only on
     * the actual logic of that action.
     */
    time(logLevel, messages, action) {
        //call the log if loglevel is in range
        if (this._logLevel >= logLevel) {
            let stopwatch = new Stopwatch_1.Stopwatch();
            let logLevelString = LogLevel[logLevel];
            //return a function to call when the timer is complete
            let done = () => {
                this[logLevelString](...messages, `finished. (${chalk_1.default.blue(stopwatch.getDurationText())})`);
            };
            stopwatch.start();
            //execute the action
            let result = action(stopwatch.stop.bind(stopwatch), stopwatch.start.bind(stopwatch));
            stopwatch.stop();
            //if this is a promise, wait for it to resolve and then return the original result
            if (typeof (result === null || result === void 0 ? void 0 : result.then) === 'function') {
                return Promise.resolve(result).then(done).then(() => {
                    return result;
                });
            }
            else {
                //this was not a promise. finish the timer now
                done();
                return result;
            }
        }
        else {
            return action(noop, noop);
        }
    }
}
exports.Logger = Logger;
Logger.emitter = new eventemitter3_1.EventEmitter();
function noop() {
}
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["error"] = 1] = "error";
    LogLevel[LogLevel["warn"] = 2] = "warn";
    LogLevel[LogLevel["log"] = 3] = "log";
    LogLevel[LogLevel["info"] = 4] = "info";
    LogLevel[LogLevel["debug"] = 5] = "debug";
    LogLevel[LogLevel["trace"] = 6] = "trace";
})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
//# sourceMappingURL=Logger.js.map