Before:
  call ale#test#SetDirectory('/testplugin/test')
  call ale#test#SetFilename('dummy.txt')

  let g:old_filename = expand('%:p')
  let g:Callback = ''
  let g:expr_list = []
  let g:message_list = []
  let g:handle_code_action_called = 0
  let g:code_actions = []
  let g:options = {}
  let g:capability_checked = ''
  let g:conn_id = v:null
  let g:InitCallback = v:null

  runtime autoload/ale/lsp_linter.vim
  runtime autoload/ale/lsp.vim
  runtime autoload/ale/util.vim
  runtime autoload/ale/rename.vim
  runtime autoload/ale/code_action.vim

  function! ale#lsp_linter#StartLSP(buffer, linter, Callback) abort
    let g:conn_id = ale#lsp#Register('executable', '/foo/bar', {})
    call ale#lsp#MarkDocumentAsOpen(g:conn_id, a:buffer)

    if a:linter.lsp is# 'tsserver'
        call ale#lsp#MarkConnectionAsTsserver(g:conn_id)
    endif

    let l:details = {
    \ 'command': 'foobar',
    \ 'buffer': a:buffer,
    \ 'connection_id': g:conn_id,
    \ 'project_root': '/foo/bar',
    \}

    let g:InitCallback = {-> ale#lsp_linter#OnInit(a:linter, l:details, a:Callback)}
  endfunction

  function! ale#lsp#HasCapability(conn_id, capability) abort
    let g:capability_checked = a:capability

    return 1
  endfunction

  function! ale#lsp#RegisterCallback(conn_id, callback) abort
    let g:Callback = a:callback
  endfunction

  function! ale#lsp#Send(conn_id, message) abort
    call add(g:message_list, a:message)

    return 42
  endfunction

  function! ale#util#Execute(expr) abort
    call add(g:expr_list, a:expr)
  endfunction

  function! ale#code_action#HandleCodeAction(code_action) abort
    let g:handle_code_action_called = 1
    call add(g:code_actions, a:code_action)
  endfunction

After:
  if g:conn_id isnot v:null
    call ale#lsp#RemoveConnectionWithID(g:conn_id)
  endif

  call ale#references#SetMap({})
  call ale#test#RestoreDirectory()
  call ale#linter#Reset()

  unlet! g:capability_checked
  unlet! g:InitCallback
  unlet! g:old_filename
  unlet! g:conn_id
  unlet! g:Callback
  unlet! g:message_list
  unlet! g:expr_list
  unlet! b:ale_linters
  unlet! g:options
  unlet! g:code_actions
  unlet! g:handle_code_action_called

  runtime autoload/ale/lsp_linter.vim
  runtime autoload/ale/lsp.vim
  runtime autoload/ale/util.vim
  runtime autoload/ale/rename.vim
  runtime autoload/ale/code_action.vim

Execute(Other messages for the tsserver handler should be ignored):
  call ale#rename#HandleTSServerResponse(1, {'command': 'foo'})
  AssertEqual g:handle_code_action_called, 0

Execute(Failed rename responses should be handled correctly):
  call ale#references#SetMap({3: {}})
  call ale#references#HandleTSServerResponse(
  \ 1,
  \ {'command': 'rename', 'request_seq': 3}
  \)
  AssertEqual g:handle_code_action_called, 0

Given typescript(Some typescript file):
  foo
  somelongerline
  bazxyzxyzxyz

Execute(Code actions should be handled):
  call ale#rename#SetMap({
  \  3: {
  \    'new_name': 'aNewName',
  \  },
  \})
  call ale#rename#HandleTSServerResponse(1, {
  \ 'command': 'rename',
  \ 'request_seq': 3,
  \ 'success': v:true,
  \ 'body': {
  \   'locs': [
  \     {
  \       'file': '/foo/bar/file1.ts',
  \       'locs': [
  \          {
  \            'start': {
  \              'line': 1,
  \              'offset': 2,
  \            },
  \            'end': {
  \              'line': 3,
  \              'offset': 4,
  \            },
  \          },
  \       ],
  \     },
  \     {
  \       'file': '/foo/bar/file2.ts',
  \       'locs': [
  \         {
  \           'start': {
  \             'line': 10,
  \             'offset': 20,
  \           },
  \            'end': {
  \              'line': 30,
  \              'offset': 40,
  \            },
  \         },
  \       ],
  \     },
  \   ]
  \ },
  \})

  AssertEqual
  \ [
  \   {
  \     'description': 'rename',
  \     'changes': [
  \       {
  \         'fileName': '/foo/bar/file1.ts',
  \         'textChanges': [
  \            {
  \              'start': {
  \                'line': 1,
  \                'offset': 2,
  \              },
  \              'end': {
  \                'line': 3,
  \                'offset': 4,
  \              },
  \              'newText': 'aNewName',
  \            },
  \         ],
  \       },
  \       {
  \         'fileName': '/foo/bar/file2.ts',
  \         'textChanges': [
  \           {
  \             'start': {
  \               'line': 10,
  \               'offset': 20,
  \             },
  \              'end': {
  \                'line': 30,
  \                'offset': 40,
  \              },
  \              'newText': 'aNewName',
  \           },
  \         ],
  \       },
  \     ],
  \   }
  \ ],
  \ g:code_actions

" Execute(The preview window should not be opened for empty tsserver responses):
"   call ale#references#SetMap({3: {}})
"   call ale#references#HandleTSServerResponse(1, {
"   \ 'command': 'references',
"   \ 'request_seq': 3,
"   \ 'success': v:true,
"   \ 'body': {
"   \   'symbolStartOffset': 9,
"   \   'refs': [
"   \   ],
"   \   'symbolDisplayString': 'import doSomething',
"   \   'symbolName': 'doSomething()',
"   \ },
"   \})

"   Assert !g:preview_called
"   AssertEqual {}, ale#references#GetMap()
"   AssertEqual ['echom ''No references found.'''], g:expr_list

" Execute(tsserver reference requests should be sent):
"   call ale#linter#Reset()

"   runtime ale_linters/typescript/tsserver.vim
"   call setpos('.', [bufnr(''), 2, 5, 0])

"   ALEFindReferences

"   " We shouldn't register the callback yet.
"   AssertEqual '''''', string(g:Callback)

"   AssertEqual type(function('type')), type(g:InitCallback)
"   call g:InitCallback()

"   AssertEqual 'references', g:capability_checked
"   AssertEqual
"   \ 'function(''ale#references#HandleTSServerResponse'')',
"   \ string(g:Callback)
"   AssertEqual
"   \ [
"   \   ale#lsp#tsserver_message#Change(bufnr('')),
"   \   [0, 'ts@references', {'file': expand('%:p'), 'line': 2, 'offset': 5}]
"   \ ],
"   \ g:message_list
"   AssertEqual {'42': {'use_relative_paths': 0}}, ale#references#GetMap()

" Execute('-relative' argument should enable 'use_relative_paths' in HandleTSServerResponse):
"   runtime ale_linters/typescript/tsserver.vim
"   call setpos('.', [bufnr(''), 2, 5, 0])

"   ALEFindReferences -relative

"   call g:InitCallback()

"   AssertEqual {'42': {'use_relative_paths': 1}}, ale#references#GetMap()

" Given python(Some Python file):
"   foo
"   somelongerline
"   bazxyzxyzxyz

" Execute(LSP reference responses should be handled):
"   call ale#references#SetMap({3: {}})
"   call ale#references#HandleLSPResponse(
"   \ 1,
"   \ {
"   \   'id': 3,
"   \   'result': [
"   \     {
"   \       'uri': ale#path#ToURI(ale#path#Simplify(g:dir . '/completion_dummy_file')),
"   \       'range': {
"   \         'start': {'line': 2, 'character': 7},
"   \       },
"   \     },
"   \     {
"   \       'uri': ale#path#ToURI(ale#path#Simplify(g:dir . '/other_file')),
"   \       'range': {
"   \         'start': {'line': 7, 'character': 15},
"   \       },
"   \     },
"   \   ],
"   \ }
"   \)

"   AssertEqual
"   \ [
"   \   {
"   \     'filename': ale#path#Simplify(g:dir . '/completion_dummy_file'),
"   \     'line': 3,
"   \     'column': 8,
"   \   },
"   \   {
"   \     'filename': ale#path#Simplify(g:dir . '/other_file'),
"   \     'line': 8,
"   \     'column': 16,
"   \   },
"   \ ],
"   \ g:item_list
"   AssertEqual {}, ale#references#GetMap()

" Execute(Preview windows should not be opened for empty LSP reference responses):
"   call ale#references#SetMap({3: {}})
"   call ale#references#HandleLSPResponse(1, {'id': 3, 'result': []})

"   Assert !g:preview_called
"   AssertEqual {}, ale#references#GetMap()
"   AssertEqual ['echom ''No references found.'''], g:expr_list

" Execute(LSP reference responses with a null result should be handled):
"   call ale#references#SetMap({3: {}})
"   call ale#references#HandleLSPResponse(1, {'id': 3, 'result': v:null})

"   Assert !g:preview_called
"   AssertEqual {}, ale#references#GetMap()
"   AssertEqual ['echom ''No references found.'''], g:expr_list

" Execute(LSP reference requests should be sent):
"   runtime ale_linters/python/pyls.vim
"   let b:ale_linters = ['pyls']
"   call setpos('.', [bufnr(''), 1, 5, 0])

"   ALEFindReferences

"   " We shouldn't register the callback yet.
"   AssertEqual '''''', string(g:Callback)

"   AssertEqual type(function('type')), type(g:InitCallback)
"   call g:InitCallback()

"   AssertEqual 'references', g:capability_checked
"   AssertEqual
"   \ 'function(''ale#references#HandleLSPResponse'')',
"   \ string(g:Callback)

"   AssertEqual
"   \ [
"   \   [1, 'textDocument/didChange', {
"   \     'textDocument': {
"   \         'uri': ale#path#ToURI(expand('%:p')),
"   \         'version': g:ale_lsp_next_version_id - 1,
"   \     },
"   \     'contentChanges': [{'text': join(getline(1, '$'), "\n") . "\n"}]
"   \   }],
"   \   [0, 'textDocument/references', {
"   \   'textDocument': {'uri': ale#path#ToURI(expand('%:p'))},
"   \   'position': {'line': 0, 'character': 2},
"   \   'context': {'includeDeclaration': v:false},
"   \   }],
"   \ ],
"   \ g:message_list

"   AssertEqual {'42': {'use_relative_paths': 0}}, ale#references#GetMap()

" Execute('-relative' argument should enable 'use_relative_paths' in HandleLSPResponse):
"   runtime ale_linters/python/pyls.vim
"   let b:ale_linters = ['pyls']
"   call setpos('.', [bufnr(''), 1, 5, 0])

"   ALEFindReferences -relative

"   call g:InitCallback()

"   AssertEqual {'42': {'use_relative_paths': 1}}, ale#references#GetMap()
